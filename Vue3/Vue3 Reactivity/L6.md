# [Vue 3 Reactivity](https://www.vuemastery.com/courses/vue-3-reactivity/vue3-reactivity/)

## Reading Source Code with Evan You

- [createGetter in baseHandlers.ts](https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/baseHandlers.ts#L37)

createGetter has a readonly version and shallow version.

Read-only allows you to create a read-only reactive object that can be read and tracked, but you cannot mutate it.

Shallow means, when you set an object into another object as a nested property, it doesn't try to convert it into reacted one.

Inside the get, first thing here is __arrayInstrumentation__:

When you have an reactive array, when you access something nested inside of it, what you get is a reactive version of the raw data.

(rare, edge case)
for example

```javaScript
const obj = {}
const arr = reactive([{}])

const reactiveObj = arr[0]

// it will be false
obj === reactiveObj

// problem above, is when you, it return -1
// -1
arr.indexOf(obj)
```

Then we're calling Reflect.get:

1. checking builtInSymbol of ES6
2. checking if shallow -> return the object without converting it.
3. checking if ref, when you nest a ref under a reactive object, and you access it, it gets automatically unwrapped.
4. then is the actual code : track()
5. when we return it, we will have to convert it, so make sure to only convert it if it's actually an object.

- [createSetter in baseHandlers.ts](https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/baseHandlers.ts#L71)

1. we're getting oldValue
2. if shallow, checking if we're setting a property in fact a ref by isRef(oldValue)
3. check if the object previously had the key (to determine it is a set operation or an add operation)

set handler is a proxy trap, it will trigger for both add and set on the same object

- When deleteProperty() is called?
using the delete keywords to delete a key
