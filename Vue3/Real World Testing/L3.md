# Mocking Vuex Stores

At the end of this lesson, we’ll have learned how to:

1. Test complex components that rely on Vue and Vuex
2. Refactor our Vuex stores to be testable
3. Mock initial test state in Vuex
4. Re-use mock data from a fixture file such as db.json
5. Simplify our tests with reusable mount functions
6. Write complex tests using the “Setup ⇒ Find ⇒ Interact ⇒ Assert” framework
7. Use data-testid to rely on resilient, markup-agnostic selectors

## Introduction

Welcome back to the third lesson of Real World Testing. In this lesson, we’ll learn how to test components that depend on Vuex and Vue Router. At the end of this lesson, we’ll have learned how to mock dependencies like Vuex and Vue Router within our tests, organize our tests, using the setup, find, interact, and assert format and use the data test ID selector to target elements.

## Assessing the Application

Currently our events application contains one test for the EventCard component.

Last lesson, this component was refactored to be presentational, meaning it only focuses on displaying data rather than fetching the data itself or maintaining any of its own data. It is also decoupled from the applications Vuex and Vue Router plugs.

Now, we must also test the EventList to ensure that the entire list of our events is being rendered correctly.
