# Reactive Variables with Type Inference

In this lesson, we’ll start using TypeScript with ref() and reactive(). Type inference is a main theme when working with reactive variables. We’ll go through some general patterns and caveats on creating reactivie variables with/without type inference.

## Reactive variables (with type inference)

Inside the <script> tag, we can now use ref() directly as if we’re still inside the setup() function:

```javaScript
<script setup lang="ts">
import { ref } frpm 'vue'

const count = ref(0)

</script>

```

Everything about ref and reactive is still the same, including type inference.

The code that we have here looks just like plain old JavaScript because the type of this variable is inferred.

Type inference is a huge part of using TypeScript. It will guess the type of the variable by just looking at the value you pass into the ref function. So even if you don’t specify the variable’s type, your IDE will still be able to show you the type info when you put your cursor over the variable.

Just like ref(), we can still use reactive() the same way as in the original Composition API syntax:

```javaScript
<script setup lang="ts">
import { ref } frpm 'vue'

const count = ref(0)

const appInfo = reactive({
  name: 'Counter',
  slogan: 'an app you can count on'
})

</script>

```

## Template

Let’s render all of our variables in the template

```javaScript
<template>
  <div>
    <h1>{{ appInfo.name }}</h1>
    <h2>{{ appInfo.slogan }}</h2>
  </div>
  <p>{{ count }}</p>
</template>
```

Even with the script setup syntax, we’re still writing template code the same way. Again, this is because the script setup syntax is still the Composition API, just under a different skin.

One subtle difference is that we didn’t have to return the appInfo and count from the setup() function because our code is not inside a function anymore.

Put your cursor on the count variable in the template, Volar will show you that its type is number not Ref<number>.

That’s because the template automatically “unpacks” the value of the Ref object.

Because of type inference, the code in this section looks just like JavaScript. (although it’s really TypeScript)

Next, we’ll write some TypeScript code that actually looks like TypeScript.

### New Convention of the Syntax

We should put the template below the script
